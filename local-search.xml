<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>requestAnimationFrame函数</title>
    <link href="/2022/10/11/requestAnimationFrame%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/11/requestAnimationFrame%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>在Web应用中，实现动画效果的方法比较多，Javascript 中可以通过定时器<code>setTimeout</code> 来实现，css3 可以使用 <code>transition</code> 和<code>animation</code> 来实现，html5 中的 canvas也可以实现。除此之外，html5 还提供一个专门用于请求动画的API，那就是<code>requestAnimationFrame</code>，顾名思义就是<strong>请求动画帧。</strong> </p><h2 id="一相关概念">一、相关概念</h2><p>为了理解 <code>requestAnimationFrame</code>背后的原理，我们首先需要了解一下与之相关的几个概念：</p><h3 id="页面可见">1.  页面可见</h3><p>   当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个<code>visibilitychange</code>事件,并设置<code>document.hidden</code>属性为<code>true</code>；切换到显示状态时，页面为可见，也同样触发一个<code>visibilitychange</code>事件，设置<code>document.hidden</code>属性为<code>false</code>。</p><h3 id="动画帧请求回调函数列表">2.  动画帧请求回调函数列表</h3><p>   每个Document都有一个动画帧请求回调函数列表，该列表可以看成是由<code>&lt;handlerId, callback&gt;</code>元组组成的集合。其中<code>handlerId</code>是一个整数，唯一地标识了元组在列表中的位置；<code>callback是</code>回调函数。</p><h3 id="屏幕刷新频率">3.  屏幕刷新频率</h3><p>   即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。对于一般笔记本电脑，这个频率大概是60Hz，这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。</p><h3 id="动画原理">4.  动画原理</h3><p>   根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而<strong>动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。</strong>那怎么样才能做到这种效果呢？</p><p>   刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。</p><h2 id="二-requestanimationframe用法">二、requestAnimationFrame用法</h2><p>异步，传入的函数在重绘之前调用。</p><h3 id="写法handlerid-requestanimationframecallback">1.  写法：handlerId= requestAnimationFrame(callback)</h3><p>(1)  传入一个<code>callback</code>函数，即动画函数;</p><p>(2) 返回值<code>handlerId</code>为浏览器定义的、大于0的整数，唯一标识了该回调函数在列表中位置。</p><h3 id="浏览器执行过程">2.  浏览器执行过程:</h3><p>(1) 首先要判断<code>document.hidden</code>属性是否为<code>true</code>,即页面处于可见状态下才会执行；</p><p>(2)  浏览器清空上一轮的动画函数；</p><p>(3)  这个方法返回的<code>handlerId</code>值会和动画函数<code>callback</code>，以<code>&lt;handlerId , callback&gt;</code>进入到动画帧请求回调函数列；</p><p>(4) 浏览器会遍历动画帧请求回调函数列表，根据<code>handlerId</code> 的值大小，依次去执行相应的动画函数。</p><h3 id="取消动画函数的方法">3.  取消动画函数的方法：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">cancelAnimationFrame</span>(handlerId)复制代码<br></code></pre></td></tr></table></figure><h2id="三settimeout与requestanimationframe">三、setTimeout与requestAnimationFrame</h2><h3 id="settimeout">1.  setTimeout</h3><p>    理解了上面的概念以后，我们不难发现，<code>setTimeout</code>其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但利用<code>seTimeout</code>实现的动画在某些低端机上会出现卡顿、抖动的现象。这种现象的产生有两个原因：</p><ul><li><code>setTimeout</code>的执行时间并不是确定的。在Javascript中，<code>setTimeout</code>任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此<strong>setTimeout的实际执行时间一般要比其设定的时间晚一些。</strong></li><li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而<code>setTimeout</code>只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li></ul><p>以上两种情况都会导致<code>setTimeout</code>的执行步调和屏幕的刷新步调不一致，从而引起<strong>丢帧</strong>现象。那为什么步调不一致就会引起丢帧呢？</p><p>首先要明白，<strong><code>setTimeout</code>的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上</strong>。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而<code>setTimeout</code>每隔10ms设置图像向左移动1px，就会出现如下绘制过程：</p><ul><li>第0ms: 屏幕未刷新，等待中，<code>setTimeout</code>也未执行，等待中；</li><li>第10ms: 屏幕未刷新，等待中，<code>setTimeout</code>开始执行并设置图像属性left=1px；</li><li>第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了<strong>1px</strong>，<code>setTimeout</code> 未执行，继续等待中；</li><li>第20ms: 屏幕未刷新，等待中，<code>setTimeout</code>开始执行并设置left=2px;</li><li>第30ms: 屏幕未刷新，等待中，<code>setTimeout</code>开始执行并设置left=3px;</li><li>第33.4ms: 屏幕开始刷新，屏幕上的图像向左移动了<strong>3px</strong>，<code>setTimeout</code>未执行，继续等待中；</li><li>…</li></ul><p>从上面的绘制过程中可以看出，屏幕没有更新left=2px的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p><h3 id="requestanimationframe">2.  requestAnimationFrame</h3><p>与<code>setTimeout</code>相比，<code>requestAnimationFrame</code>最大的优势是<strong>由系统来决定回调函数的执行时机。</strong>具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，<code>requestAnimationFrame</code>的步伐跟着系统的刷新步伐走。<strong>它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次</strong>，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p><p>这个API的调用很简单，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> progress = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;  <br>  progress += <span class="hljs-number">1</span>; <span class="hljs-comment">//修改图像的位置  </span><br>  <span class="hljs-keyword">if</span> (progress &lt; <span class="hljs-number">100</span>) &#123;  <span class="hljs-comment">//在动画没有结束前，递归渲染    </span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(render); <br>  &#125;<br>&#125;<br><span class="hljs-comment">//第一帧渲染</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(render);复制代码<br></code></pre></td></tr></table></figure><p>除此之外，<code>requestAnimationFrame</code>还有以下两个优势：</p><ul><li><p><strong>CPU节能</strong>：使用<code>setTimeout</code>实现的动画，当页面被隐藏或最小化时，<code>setTimeout</code>仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而<code>requestAnimationFrame</code>则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的<code>requestAnimationFrame</code>也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</p></li><li><p><strong>函数节流</strong>：在高频率事件(<code>resize</code>,<code>scroll</code>等)中，为了防止在一个刷新间隔内发生多次函数执行，使用<code>requestAnimationFrame</code>可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</p></li></ul><h3 id="优雅降级">3.  优雅降级</h3><p>   由于<code>requestAnimationFrame</code>目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀。因此需要通过优雅降级的方式对<code>requestAnimationFrame</code>进行封装，优先使用高级特性，然后再根据不同浏览器的情况进行回退，直至只能使用<code>setTimeout</code>的情况。下面的代码就是有人在github上提供的polyfill，详细介绍请参考github代码<ahref="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdarius%2FrequestAnimationFrame"title="https://github.com/darius/requestAnimationFrame">requestAnimationFrame</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>)<br>    <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>(); &#125;;<br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-string">&#x27;use strict&#x27;</span>;<br><br>    <span class="hljs-keyword">var</span> vendors = [<span class="hljs-string">&#x27;webkit&#x27;</span>, <span class="hljs-string">&#x27;moz&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; vendors.<span class="hljs-property">length</span> &amp;&amp; !<span class="hljs-variable language_">window</span>.<span class="hljs-property">requestAnimationFrame</span>; ++i) &#123;<br>        <span class="hljs-keyword">var</span> vp = vendors[i];<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">requestAnimationFrame</span> = <span class="hljs-variable language_">window</span>[vp+<span class="hljs-string">&#x27;RequestAnimationFrame&#x27;</span>];<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">cancelAnimationFrame</span> = (<span class="hljs-variable language_">window</span>[vp+<span class="hljs-string">&#x27;CancelAnimationFrame&#x27;</span>]<br>                                   || <span class="hljs-variable language_">window</span>[vp+<span class="hljs-string">&#x27;CancelRequestAnimationFrame&#x27;</span>]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/iP(ad|hone|od).*OS 6/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">navigator</span>.<span class="hljs-property">userAgent</span>) <span class="hljs-comment">// iOS6 is buggy</span><br>        || !<span class="hljs-variable language_">window</span>.<span class="hljs-property">requestAnimationFrame</span> || !<span class="hljs-variable language_">window</span>.<span class="hljs-property">cancelAnimationFrame</span>) &#123;<br>        <span class="hljs-keyword">var</span> lastTime = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">requestAnimationFrame</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>            <span class="hljs-keyword">var</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>            <span class="hljs-keyword">var</span> nextTime = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(lastTime + <span class="hljs-number">16</span>, now);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">callback</span>(lastTime = nextTime); &#125;,<br>                              nextTime - now);<br>        &#125;;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">cancelAnimationFrame</span> = <span class="hljs-built_in">clearTimeout</span>;<br>    &#125;<br>&#125;());<br>复制代码<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>判断子序列</title>
    <link href="/2022/10/10/%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/10/10/%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>给定一个长度为 <span class="math inline">\(n\)</span> 的整数序列<span class="math inline">\(a_1,a_2,…,a_n\)</span> 以及一个长度为 <spanclass="math inline">\(m\)</span> 的整数序列 <spanclass="math inline">\(b_1,b_2,…,b_m\)</span>。</p><p>请你判断 <span class="math inline">\(a\)</span> 序列是否为 <spanclass="math inline">\(b\)</span> 序列的子序列。</p><p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列<span class="math inline">\(\\{a_1,a_3,a5\\}\)</span> 是序列 <spanclass="math inline">\(\\{a_1,a_2,a_3,a_4,a_5\\}\)</span>的一个子序列。</p><h4 id="输入格式">输入格式</h4><p>第一行包含两个整数 <span class="math inline">\(n,m\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数，表示 <spanclass="math inline">\(a_1,a_2,…,a_n\)</span>。</p><p>第三行包含 <span class="math inline">\(m\)</span> 个整数，表示 <spanclass="math inline">\(b_1,b_2,…,b_m\)</span>。</p><h4 id="输出格式">输出格式</h4><p>如果 <span class="math inline">\(a\)</span> 序列是 <spanclass="math inline">\(b\)</span> 序列的子序列，输出一行<code>Yes</code>。</p><p>否则，输出 <code>No</code>。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1 \le n \le m \le 10^5\)</span>,<br /><span class="math inline">\(-10^9 \le a_i,b_i \le 10^9\)</span></p><h4 id="输入样例">输入样例：</h4><pre><code class="hljs">3 51 3 51 2 3 4 5</code></pre><h4 id="输出样例">输出样例：</h4><pre><code class="hljs">Yes</code></pre><hr /><h3 id="算法">算法</h3><h4 id="双指针-onm">(双指针) <spanclass="math inline">\(O(n+m)\)</span></h4><ol type="1"><li><p>j指针用来扫描整个b数组，i指针用来扫描a数组。若发现a[i] ==b[j]，则让i指针后移一位。</p></li><li><p>整个过程中，j指针不断后移，而i指针只有当匹配成功时才后移一位，若最后若i== n，则说明匹配成功。</p></li></ol><p>整个过程中j指针不断扫描b数组并且向后移动，相当于不断给i指针所指向的a数组创建匹配的机会，只有匹配成功时i指针才会向后移动一位，当i== n时，说明全部匹配成功。</p><p><imgsrc="https://img-blog.csdnimg.cn/2021040121250352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" /></p><h4 id="java-代码">Java 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">my code...<span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> []b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            a[i] = in.nextInt();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)<br>            b[j] = in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>            <span class="hljs-keyword">if</span>(i &lt; n &amp;&amp; a[i] == b[j])<br>                i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( i == n)<br>            System.out.println(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <br>            System.out.println(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组元素目标和</title>
    <link href="/2022/10/06/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <url>/2022/10/06/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>给定两个升序排序的有序数组 <span class="math inline">\(A\)</span> 和<span class="math inline">\(B\)</span>，以及一个目标值 <spanclass="math inline">\(x\)</span>。</p><p>数组下标从 <span class="math inline">\(0\)</span> 开始。</p><p>请你求出满足 <span class="math inline">\(A[i] + B[j] = x\)</span>的数对 <span class="math inline">\((i, j)\)</span>。</p><p>数据保证有唯一解。</p><h4 id="输入格式">输入格式</h4><p>第一行包含三个整数 <spanclass="math inline">\(n,m,x\)</span>，分别表示 <spanclass="math inline">\(A\)</span> 的长度，<spanclass="math inline">\(B\)</span> 的长度以及目标值 <spanclass="math inline">\(x\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数，表示数组<span class="math inline">\(A\)</span>。</p><p>第三行包含 <span class="math inline">\(m\)</span> 个整数，表示数组<span class="math inline">\(B\)</span>。</p><h4 id="输出格式">输出格式</h4><p>共一行，包含两个整数 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>。</p><h4 id="数据范围">数据范围</h4><p>数组长度不超过 <span class="math inline">\(10^5\)</span>。<br />同一数组内元素各不相同。<br /><span class="math inline">\(1 \le 数组元素 \le 10^9\)</span></p><h4 id="输入样例">输入样例：</h4><pre><code class="hljs">4 5 61 2 4 73 4 6 8 9</code></pre><h4 id="输出样例">输出样例：</h4><pre><code class="hljs">1 1</code></pre><h3 id="思路">思路：</h3><figure><imgsrc="https://cdn.acwing.com/media/article/image/2020/12/06/2675_d09ec25337-1.png"alt="思路" /><figcaption aria-hidden="true">思路</figcaption></figure><h3 id="java代码">java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> []a= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> []b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            a[i] = in.nextInt();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)<br>            b[i] = in.nextInt();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(a[i] + b[j] &gt; x &amp;&amp; j &gt; <span class="hljs-number">0</span>)<br>                j--;<br>            <span class="hljs-keyword">if</span>(a[i] + b[j] == x)&#123;<br>                System.out.println(i + <span class="hljs-string">&quot; &quot;</span> + j);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长连续不重复子序列</title>
    <link href="/2022/10/06/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/10/06/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>给定一个长度为 <span class="math inline">\(n\)</span>的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h4 id="输入格式">输入格式</h4><p>第一行包含整数 <span class="math inline">\(n\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数（均在 <spanclass="math inline">\(0 \sim 10^5\)</span> 范围内），表示整数序列。</p><h4 id="输出格式">输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1 \le n \le 10^5\)</span></p><h4 id="输入样例">输入样例：</h4><pre><code class="hljs">51 2 2 3 5</code></pre><h4 id="输出样例">输出样例：</h4><pre><code class="hljs">3</code></pre><h3 id="思路">思路</h3><ol type="1"><li><p>遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j,i]维护的是以a[i]结尾的最长连续不重复子序列，长度为i - j + 1,将这一长度与r的较大者更新给r。</p></li><li><p>对于每一个i，如何确定j的位置：由于[j, i -1]是前一步得到的最长连续不重复子序列，所以如果[j,i]中有重复元素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i -1]已经是前一步的最优解，此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。</p></li><li><p>用数组s记录子序列a[j ~i]中各元素出现次数，遍历过程中对于每一个i有四步操作：cin元素a[i] -&gt;将a[i]出现次数s[a[i]]加1 -&gt; 若a[i]重复则右移j（s[a[j]]要减1） -&gt;确定j及更新当前长度i - j + 1给r。</p></li></ol><h3 id="java代码">java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-type">int</span> [] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];<br>        <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        n = cin.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            a[i] = cin.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++ )&#123;<br>            b[a[i]] += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(b[a[i]] &gt; <span class="hljs-number">1</span>)&#123;<br>                b[a[j]] -= <span class="hljs-number">1</span>;<br>                j++;<br>            &#125;<br>            res = Math.max(res,i-j+<span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数的范围</title>
    <link href="/2022/10/05/%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4/"/>
    <url>/2022/10/05/%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<p>给定一个按照升序排列的长度为 <span class="math inline">\(n\)</span>的整数数组，以及 <span class="math inline">\(q\)</span> 个查询。</p><p>对于每个查询，返回一个元素 <span class="math inline">\(k\)</span>的起始位置和终止位置（位置从 <span class="math inline">\(0\)</span>开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="输入格式">输入格式</h4><p>第一行包含整数 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(q\)</span>，表示数组长度和询问个数。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数（均在 <spanclass="math inline">\(1 \sim 10000\)</span> 范围内），表示完整数组。</p><p>接下来 <span class="math inline">\(q\)</span> 行，每行包含一个整数<span class="math inline">\(k\)</span>，表示一个询问元素。</p><h4 id="输出格式">输出格式</h4><p>共 <span class="math inline">\(q\)</span>行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1 \le n \le 100000\)</span><br /><span class="math inline">\(1 \le q \le 10000\)</span><br /><span class="math inline">\(1 \le k \le 10000\)</span></p><h4 id="输入样例">输入样例：</h4><pre><code class="hljs">6 31 2 2 3 3 4345</code></pre><h4 id="输出样例">输出样例：</h4><pre><code class="hljs">3 45 5-1 -1</code></pre><h3 id="c代码">c++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,q;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>&#125;<br><span class="hljs-keyword">while</span>(q--)&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)<br>    &#123;<br>        <span class="hljs-type">int</span> mid=i+j&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=k)j=mid;<br>        <span class="hljs-keyword">else</span> i=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(a[i]!=k)cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=i+j+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[mid]&lt;=k)i=mid;<br>            <span class="hljs-keyword">else</span> j=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        cout&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程技术点(一)</title>
    <link href="/2022/10/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E7%82%B9(%E4%B8%80)/"/>
    <url>/2022/10/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E7%82%B9(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3id="一什么是进程线程协程他们之间的关系是怎样的">一、什么是进程、线程、协程，他们之间的关系是怎样的</h3><p>进程:本质上是一个独立执行的程序，进程是操作系统进行资源分配和调度的基本概念，操作系统进行资源分配和调度的一个独立单位</p><p>线程:是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程执行不同的任务，切换受系统控制。</p><p>协程:又称为微线程，是一种用户态的轻量级线程，协程不像线程和进程需要进行系统内核上的上下文切换，协程的上下文切换是由用户自己决定的，有自己的上下文，所以说是轻量级的线程，也称之为用户级别的线程就叫协程，一个线程可以多个协程,线程进程都是同步机制，而协程则是异步</p><p>Java的原生语法中并没有实现协程,目前python、Lua和GO等语言支持</p><p>关系：一个进程可以有多个线程，它允许计算机同时运行两个或多个程序。线程是进程的最小执行单位，CPU的调度切换的是进程和线程，进程和线程多了之后调度会消耗大量的CPU，CPU上真正运行的是线程，线程可以对应多个协程</p><ul><li><p>协程对于多线程有什么优缺点吗</p><p>优点：</p><pre><code class="hljs">非常快速的上下文切换，不用系统内核的上下文切换，减小开销单线程即可实现高并发，单核CPU可以支持上万的协程由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁</code></pre><p>缺点：</p><pre><code class="hljs">协程无法利用多核资源，本质也是个单线程协程需要和进程配合才能运行在多CPU上目前java没成熟的第三方库，存在风险调试debug存在难度，不利于发现问题</code></pre></li></ul><h3 id="二并发并行的区别">二、并发、并行的区别</h3><p>并发 concurrency： 一台处理器上同时处理任务,这个同时实际上是交替处理多个任务，程序中可以同时拥有两个或者多个线程，当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行</p><p>并行 parallellism：多个CPU上同时处理多个任务，一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行</p><p>并发指在一段时间内宏观上去处理多个任务。并行指同一个时刻，多个任务确实真的同时运行。</p><p>例子：</p><p>并发是一心多用，听课和看电影，但是CPU大脑只有一个，所以轮着来并行：火影忍者中的影分身，有多个你出现，可以分别做不同的事情一个项目经理A和3个程序B C D的故事</p><p>单线程并发：A给B讲完需求，B自己去实现，期间A继续给C和D讲，不用等待某个程序员去完成，期间项目经理没空闲下来</p><p>并行：直接找3个项目经理分别分配给3个程序员</p><h3id="三java多线程的实现方式和区别">三、Java多线程的实现方式和区别</h3><p><strong>简介: Java多线程的实现方式和区别</strong></p><ul><li><p>继承Thread</p></li><li><p>继承Thread，重写里面run方法，创建实例，执行start优点：代码编写最简单直接操作缺点：没返回值，继承一个类后，没法继承其他的类，拓展性差</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">继承Thread，重写里面run方法，创建实例，执行start<br>优点：代码编写最简单直接操作<br>缺点：没返回值，继承一个类后，没法继承其他的类，拓展性差<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;继承Thread实现多线程，名称：&quot;</span>+Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>public static void main(String[] args) {</p><pre><code class="hljs">  ThreadDemo1 threadDemo1 = new ThreadDemo1();  threadDemo1.setName(&quot;demo1&quot;);  threadDemo1.start();  System.out.println(&quot;主线程名称：&quot;+Thread.currentThread().getName());</code></pre><p>}</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- 实现Runnable<br><br>```java<br>自定义类实现Runnable，实现里面run方法，创建Thread类，使用Runnable接口的实现对象作为参数传递给Thread对象，调用Strat方法<br><br>优点：线程类可以实现多个几接口，可以再继承一个类<br>缺点：没返回值，不能直接启动，需要通过构造一个Thread实例传递进去启动<br><br><br>public <span class="hljs-keyword">class</span> ThreadDemo2 implements Runnable &#123;<br><br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;通过Runnable实现多线程，名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>&#125;<br><br><br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ThreadDemo2 threadDemo2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo2()</span>;<br>        Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">threadDemo2</span>)</span>;<br>        thread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;demo2&quot;</span>)</span>;<br>        thread.start<span class="hljs-literal">()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>&#125;<br><br>JDK8之后采用lambda表达式<br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;通过Runnable实现多线程，名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>            &#125;);<br>    thread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;demo2&quot;</span>)</span>;<br>    thread.start<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>通过Callable和FutureTask方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">创建callable接口的实现类，并实现call方法，结合FutureTask类包装Callable对象，实现多线程<br>优点：有返回值，拓展性也高<br>缺点：jdk5以后才支持，需要重写call方法，结合多个类比如FutureTask和Thread类<br></code></pre></td></tr></table></figure><p>public class MyTask implements Callable<Object> { <spanclass="citation" data-cites="Override">@Override</span> public Objectcall() throws Exception {</p><pre><code class="hljs">    System.out.println(&quot;通过Callable实现多线程，名称：&quot;+Thread.currentThread().getName());    return &quot;这是返回值&quot;;&#125;</code></pre><p>}</p><p>public static void main(String[] args) {</p><pre><code class="hljs">    FutureTask&lt;Object&gt; futureTask = new FutureTask&lt;&gt;(()-&gt;&#123;        System.out.println(&quot;通过Callable实现多线程，名称：&quot;+Thread.currentThread().getName());        return &quot;这是返回值&quot;;    &#125;);</code></pre><p>// MyTask myTask = new MyTask(); // FutureTask<Object> futureTask =new FutureTask&lt;&gt;(myTask);</p><pre><code class="hljs">    //FutureTask继承了Runnable，可以放在Thread中启动执行    Thread thread = new Thread(futureTask);    thread.setName(&quot;demo3&quot;);    thread.start();    System.out.println(&quot;主线程名称:&quot;+Thread.currentThread().getName());    try &#123;        System.out.println(futureTask.get());    &#125; catch (InterruptedException e) &#123;        //阻塞等待中被中断，则抛出        e.printStackTrace();    &#125; catch (ExecutionException e) &#123;        //执行过程发送异常被抛出        e.printStackTrace();    &#125;&#125;</code></pre></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- 通过线程池创建线程<br><br>```java<br>自定义Runnable接口，实现run方法，创建线程池，调用执行方法并传入对象<br>优点：安全高性能，复用线程<br>缺点: jdk5后才支持，需要结合Runnable进行使用 <br>public <span class="hljs-keyword">class</span> ThreadDemo4 implements Runnable &#123; <br>@Override<br> public void run<span class="hljs-literal">()</span> &#123;<br> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;通过线程池+runnable实现多线程，名称：&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br> &#125;<br>&#125; <br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br> ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(3)</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br> executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadDemo4()</span>);<br> &#125; <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;主线程名称:&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>); <br><span class="hljs-comment">//关闭线程池</span><br> executorService.shutdown<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般常用线程池和和runanble，简单方便扩展和高性能</p><h3 id="四线程有几种状态">四、<strong>线程有几种状态</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs context">JDK的线程状态分6种，JVM里面9种，我们一般说JDK的线程状态<br><br>常见的5种状态<br><br>创建(NEW): 生成线程对象，但是并没有调用该对象start(), new Thread()<br><br>就绪(Runnable)：当调用线程对象的start()方法，线程就进入就绪状态，但是此刻线程调度还没把该线程设置为当前线程，就是没获得CPU使用权。   如果线程运行后，从等待或者睡眠中回来之后，也会进入就绪状态<br>    注意:有些文档把就绪和运行两种状态统一称为 “运行中”<br><br>运行(Running)<br>    程序将处于就绪状态的线程设置为当前线程，即获得CPU使用权，这个时候线程进入运行状态，开始运行run里面的逻辑<br><br>阻塞(Blocked)<br>    等待阻塞：进入该状态的线程需要等待其他线程作出一定动作(通知或中断)，这种状态的话CPU不会分配过来，他们需要被唤醒，可能也会无限等待下去。比如调用wait(状态就会变成WAITING状态)，也可能通过调用sleep(状态就会变成TIMED_WAITING), join或者发出IO请求，阻塞结束后线程重新进入就绪状态<br><br>    同步阻塞：线程在获取synchronized同步锁失败，即锁被其他线程占用，它就会进入同步阻塞状态<br><br>    备注：相关资料会用细分下面的状态<br>        等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。<br>        超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回<br><br><br>死亡(TERMINATED):一个线程run方法执行结束，该线程就死亡了，不能进入就绪状态<br></code></pre></td></tr></table></figure><h3 id="五多线程开发里面常用的方法">五、多线程开发里面常用的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs context">sleep<br>    属于线程Thread的方法<br>    让线程暂缓执行，等待预计时间之后再恢复<br>    交出CPU使用权，不会释放锁<br>    进入阻塞状态TIME_WAITGING，睡眠结束变为就绪Runnable<br><br>yield<br>    属于线程Thread的方法<br>    t1/t2/t3<br>    暂停当前线程的对象，去执行其他线程<br>    交出CPU使用权，不会释放锁，和sleep类似<br>    作用：让相同优先级的线程轮流执行，但是不保证一定轮流<br>    注意：不会让线程进入阻塞状态，直接变为就绪Runnable，只需要重新获得CPU使用权<br><br><br>join  <br>    属于线程Thread的方法<br>    在主线程上运行调用该方法，会让主线程休眠，不会释放已经持有的对象锁<br>    让调用join方法的线程先执行完毕，在执行其他线程<br>    类似让救护车警车优先通过<br><br>wait<br>    属于Object的方法<br>    当前线程调用对象的wait方法，会释放锁，进入线程的等待队列<br>    需要依靠notify或者notifyAll唤醒，或者wait(timeout)时间自动唤醒<br><br>notify<br>    属于Object的方法<br>    唤醒在对象监视器上等待的单个线程，选择是任意的<br><br>notifyAll<br>    属于Object的方法<br>    唤醒在对象监视器上等待的全部线程<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java集合框架List</title>
    <link href="/2022/09/30/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6List/"/>
    <url>/2022/09/30/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6List/</url>
    
    <content type="html"><![CDATA[<h3id="vector和arraylistlinkedlist联系和区别分别的使用场景">Vector和ArrayList、LinkedList联系和区别？分别的使用场景</h3><ul><li>线程安全<ul><li>ArrayList：底层是数组实现，线程不安全，查询和修改非常快，但是增加和删除慢</li><li>LinkedList:底层是双向链表，线程不安全，查询和修改速度慢，但是增加和删除速度快</li><li>Vector:底层是数组实现，线程安全的，操作的时候使用synchronized进行加锁</li></ul></li><li>使用场景<ul><li>Vector已经很少用了</li><li>增加和删除场景多则用LinkedList</li><li>查询和修改多则用ArrayList</li></ul></li></ul><h3id="如果需要保证线程安全arraylist应该怎么做">如果需要保证线程安全，ArrayList应该怎么做</h3><ol type="1"><li>方式一：自己写个包装类，根据业务一般是add/update/remove加锁</li><li>方式二：Collections.synchronizedList(new ArrayList&lt;&gt;());使用synchronized加锁</li><li>方式三：CopyOnWriteArrayList&lt;&gt;() 使用ReentrantLock加锁</li></ol><h3id="collections.synchronizedlist和copyonwritearraylist区别">Collections.synchronizedList和CopyOnWriteArrayList&lt;&gt;()区别</h3><ul><li>CopyOnWriteArrayList：执行修改操作时，会拷贝一份新的数组进行操作（add、set、remove等)，代价十分昂贵，在执行完修改后将原来集合指向新的集合来完成修改操作，源码里面用ReentrantLock可重入锁来保证不会有多个线程同时拷贝一份数组<ul><li>场景：读高性能，适用读操作远远大于写操作的场景中使用(读的时候是不需要加锁的，直接获取，删除和增加是需要加锁的,读多写少)</li></ul></li><li>Collections.synchronizedList：线程安全的原因是因为它几乎在每个方法中都使用了synchronized同步*锁<ul><li>场景：写操作性能比CopyOnWriteArrayList好，读操作性能并不如CopyOnWriteArrayList</li></ul></li></ul><h3id="copyonwritearraylist的设计思想是怎样的有什么缺点">CopyOnWriteArrayList的设计思想是怎样的,有什么缺点？</h3><ul><li><p>设计思想：读写分离+最终一致</p><p>缺点：内存占用问题,写时复制机制,内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象,如果对象大则容易发生YongGC和Full GC</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>try-catch-finally执行流程</title>
    <link href="/2022/09/29/try-catch-finally%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/09/29/try-catch-finally%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的</p><p>执行流程：finally执行前的代码里面有包含return，则会先确定return返回值，然后再执行finally的代码，最后再执行return</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(a / <span class="hljs-number">0</span>);<br>            a = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            a = <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">return</span> a; <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            a = <span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上段代码最后返回值为3；执行try语句时，发生异常，catch中捕获，catch中有return语句，此时确定返回值为3，然后执行finally块，finally执行结束后回到catch，返回值已经确定，finally中重新赋值不会影响返回值，所以返回3；</p><p>下一段代码，finally中也有返回语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           System.out.println(a / <span class="hljs-number">0</span>);<br>           a = <span class="hljs-number">2</span>;<br>       &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>           a = <span class="hljs-number">3</span>;<br>           <span class="hljs-keyword">return</span> a;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           a = <span class="hljs-number">4</span>; <br>           <span class="hljs-keyword">return</span> a;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>此时返回4，在finally中遇到return语句，重新确定返回值，并且执行返回语句，程序结束。</p>]]></content>
    
    
    <categories>
      
      <category>Java语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符</title>
    <link href="/2022/09/29/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/09/29/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一运算符-和和的区别">一、运算符&amp;和&amp;&amp;、|和||的区别</h3><blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp; 按位与操作</span><br>    只有对应的两个二进制数为<span class="hljs-number">1</span>时，结果位才为<span class="hljs-number">1</span><br>    <span class="hljs-number">1</span><span class="hljs-meta">&amp;1 = 1</span><br>    <span class="hljs-number">1</span><span class="hljs-meta">&amp;0 = 0</span><br>    <span class="hljs-number">0</span><span class="hljs-meta">&amp;1 = 0</span><br>    <span class="hljs-number">0</span><span class="hljs-meta">&amp;0 = 0</span><br><span class="hljs-string">| 按位或操作</span><br>    有一个为<span class="hljs-number">1</span>的时候，结果位就为<span class="hljs-number">1</span><br>    <span class="hljs-number">1</span><span class="hljs-string">|1 = 1</span><br>    <span class="hljs-number">1</span><span class="hljs-string">|0 = 1</span><br>    <span class="hljs-number">0</span><span class="hljs-string">|1 = 1</span><br>    <span class="hljs-number">0</span><span class="hljs-string">|0 = 0</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp; 和 &amp;&amp; 都可以实现 和 这个功能</span><br>区别：<span class="hljs-meta">&amp; 两边都运算，而 &amp;&amp; 先算 &amp;&amp; 左侧，若左侧为false 那么右侧就不运算，判断语句中推荐使用 &amp;&amp;，效率更高</span><br><br><span class="hljs-string">| 和 || 和上面类似</span><br>区别：<span class="hljs-string">||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断</span><br><br>把<span class="hljs-meta">&amp;&amp;和||称之为短路运算符</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="二">二、&lt;<和>&gt;</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">将一个数左移<span class="hljs-built_in">n</span>位，相当于乘以<span class="hljs-number">2</span>的<span class="hljs-built_in">n</span>次方，位运算是CPU直接支持的，所以效率高<br></code></pre></td></tr></table></figure><p>计算2*8 使用<code>2 &lt;&lt; 3</code> 比<code>2*8</code>效率更高</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">常见的JDK源码里面HashMap的默认容量16<br>int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; <span class="hljs-string">4; // aka 16</span><br><span class="hljs-string"></span><br><span class="hljs-string">直接是二进制操作了，表示1左移4</span>位，变成10000，转为10进制也就是16, 直接以二进制形式去运行，效率更高<br></code></pre></td></tr></table></figure><h3 id="三运算符">三、^运算符</h3><p>传递两个非0的int数值进去，实现变量交换的方式，有几种方式？</p><ol type="1"><li><p>```java public static void swap(int a, int b){</p><pre><code class="hljs">    System.out.printf(&quot;a=%d, b=%d&quot;,a,b);    a = a + b;    b = a - b ;    a = a - b;    System.out.printf(&quot;\na=%d, b=%d&quot;,a,b);&#125;</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <br>   通过加减运算实现交换，不需要额外定义变量<br><br><span class="hljs-number">2.</span> 异或运算 (一个数与另一个数异或两次是其本身， 一个数和自身异或结果是<span class="hljs-number">0</span> )<br>   <br>   ```<span class="hljs-function">java</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">swap2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>   <br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d, b=%d&quot;</span>,a,b);<br>   <br>        a = a^b;   <span class="hljs-comment">// a1 = a^b</span><br>        b = b^a;   <span class="hljs-comment">// b = b^a^b</span><br>        a = a^b;   <span class="hljs-comment">// a = a1^b = a^b^a</span><br>   <br>        System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\na=%d, b=%d&quot;</span>,a,b);<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过^运算符，效率更高</p></li></ol><h3 id="四和euqals">四、==和euqals</h3><ul><li>基本数据类型比较 要用==判断是否相等</li><li>引用数据类型：==比较的是内存地址是否一样，不同对象的内存地址不一样，equals比较的是具体的内容，也可以让开发者去定义什么条件去判断两个对象是否一样</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda</title>
    <link href="/2022/09/28/Lambda/"/>
    <url>/2022/09/28/Lambda/</url>
    
    <content type="html"><![CDATA[<h2 id="lambda表达式">Lambda表达式</h2><h3 id="简介">简介</h3><p>Lambda表达式（也称闭包），是Java8中最受期待和欢迎的新特性之一。在Java语法层面Lambda表达式允许函数作为一个方法的参数（函数作为参数传递到方法中），或者把代码看成数据。Lambda表达式可以简化函数式接口的使用。函数式接口就是一个只具有一个抽象方法的普通接口，像这样的接口就可以使用Lambda表达式来简化代码的编写。</p><p><strong>使用Lambda表达式的前提</strong><strong>对应接口有且只有一个抽象方法！！</strong>！</p><h3 id="基础语法">基础语法</h3><p>Lambda 表达式的基础语法：Java8中引入了一个新的操作符 “-&gt;”该操作符称为箭头操作符或 Lambda 操作符 箭头操作符将 Lambda表达式拆分成两部分： 左侧：Lambda 表达式的参数列表 右侧：Lambda表达式中所需执行的功能， 即 Lambda 体<code>(args1, args2...) -&gt; &#123;&#125;;</code></p><h3 id="lambda表达式的重要特征">Lambda表达式的重要特征</h3><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><h3 id="使用lambda表达式的优缺点">使用Lambda表达式的优缺点</h3><ul><li><p>优点</p><p>使用Lambda表达式可以简化接口匿名内部类的使用，可以减少类文件的生成</p></li><li><p>缺点</p><p>使用Lambda表达式会减弱代码的可读性，而且Lambda表达式的使用局限性比较强，只能适用于接口只有一个抽象方法时使用，不宜调试。</p></li></ul><h3 id="使用案例">使用案例</h3><ol type="1"><li><p>例1、用lambda表达式实现Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 8之前：</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Before Java8, too much code for too little to do&quot;</span>);<br>    &#125;<br>&#125;).start();<br><br><span class="hljs-comment">//Java 8方式：</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( () -&gt; System.out.println(<span class="hljs-string">&quot;In Java8, Lambda expression rocks !!&quot;</span>) ).start();<br></code></pre></td></tr></table></figure></li><li><p>例2、使用Java 8 lambda表达式进行事件处理</p><p>如果你用过SwingAPI编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 8之前：</span><br><span class="hljs-type">JButton</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;Show&quot;</span>);<br>show.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActionListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Event handling without lambda expression is boring&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// Java 8方式：</span><br>show.addActionListener((e) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Light, Camera, Action !! Lambda expressions Rocks&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>例3、使用lambda表达式对列表进行迭代</p><p>如果你使过几年Java，你就知道针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。下面的例子里，我将介绍如何在使用lambda或不使用lambda表达式的情况下迭代列表。你可以看到列表现在有了一个forEach() 方法，它可以迭代所有对象，并将你的lambda代码应用在其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 8之前：</span><br><span class="hljs-type">List</span> <span class="hljs-variable">features</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-string">&quot;Lambdas&quot;</span>, <span class="hljs-string">&quot;Default Method&quot;</span>, <span class="hljs-string">&quot;Stream API&quot;</span>, <span class="hljs-string">&quot;Date and Time API&quot;</span>);<br><span class="hljs-keyword">for</span> (String feature : features) &#123;<br>    System.out.println(feature);<br>&#125;<br><br><span class="hljs-comment">// Java 8之后：</span><br><span class="hljs-type">List</span> <span class="hljs-variable">features</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-string">&quot;Lambdas&quot;</span>, <span class="hljs-string">&quot;Default Method&quot;</span>, <span class="hljs-string">&quot;Stream API&quot;</span>, <span class="hljs-string">&quot;Date and Time API&quot;</span>);<br>features.forEach(n -&gt; System.out.println(n));<br><br><span class="hljs-comment">// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，</span><br><span class="hljs-comment">// 看起来像C++的作用域解析运算符</span><br>features.forEach(System.out::println);<br></code></pre></td></tr></table></figure></li></ol><h3 id="小结">小结</h3><p>lambda表达式可以是使代码更为简洁，java9新特性中加入Stream。Stream使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java集合运算和表达的高阶抽象。</p><p>StreamAPI可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输，并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediateoperation）的处理，最后由最终操作(terminaloperation)得到前面处理的结果。</p><p>lambda在Stream中进行操作时会被大量使用。</p>]]></content>
    
    
    <categories>
      
      <category>Java语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2022/09/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/09/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>给定你一个长度为 <span class="math inline">\(n\)</span>的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式">输入格式</h4><p>输入共两行，第一行包含整数 <spanclass="math inline">\(n\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span>个整数（所有整数均在 <span class="math inline">\(1 \sim 10^9\)</span>范围内），表示整个数列。</p><h4 id="输出格式">输出格式</h4><p>输出共一行，包含 <span class="math inline">\(n\)</span>个整数，表示排好序的数列。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1 \le n \le 100000\)</span></p><h4 id="输入样例">输入样例：</h4><pre><code class="hljs">53 1 2 4 5</code></pre><h4 id="输出样例">输出样例：</h4><pre><code class="hljs">1 2 3 4 5</code></pre><h3 id="参考代码">参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N],t[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i=l,mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid),<span class="hljs-built_in">merge_sort</span>(a,j,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j])t[k++]=a[i++];<br>        <span class="hljs-keyword">else</span> t[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)t[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)t[k++]=a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,k=<span class="hljs-number">0</span>;i&lt;=r;i++)a[i]=t[k++];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">merge_sort</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/09/27/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/09/27/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>给定你一个长度为 <span class="math inline">\(n\)</span>的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式">输入格式</h4><p>输入共两行，第一行包含整数 <spanclass="math inline">\(n\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span>个整数（所有整数均在 <span class="math inline">\(1 \sim 10^9\)</span>范围内），表示整个数列。</p><h4 id="输出格式">输出格式</h4><p>输出共一行，包含 <span class="math inline">\(n\)</span>个整数，表示排好序的数列。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1 \le n \le 100000\)</span></p><h4 id="输入样例">输入样例：</h4><pre><code class="hljs">53 1 2 4 5</code></pre><h4 id="输出样例">输出样例：</h4><pre><code class="hljs">1 2 3 4 5</code></pre><h3 id="参考代码">参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num];<br>        String[] res = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            arr[i] = Integer.parseInt(res[i]);<br>        &#125;<br>        quickSort(arr, <span class="hljs-number">0</span>, num-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        br.close();<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] q, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>         <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l-<span class="hljs-number">1</span>, j = r+<span class="hljs-number">1</span>;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span>;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span>  q[mid];<br>         <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>             <span class="hljs-keyword">while</span>(q[++i] &lt; x);<br>             <span class="hljs-keyword">while</span>(q[--j] &gt; x);<br>             <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> q[i];<br>                q[i] = q[j];<br>                q[j] = temp;<br>            &#125;<br>         &#125;<br>         quickSort(q,l,j);<br>         quickSort(q,j+<span class="hljs-number">1</span>,r);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP字符串</title>
    <link href="/2022/09/26/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/09/26/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>给定一个字符串 <span class="math inline">\(S\)</span>，以及一个模式串<spanclass="math inline">\(P\)</span>，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模式串 <span class="math inline">\(P\)</span> 在字符串 <spanclass="math inline">\(S\)</span> 中多次作为子串出现。</p><p>求出模式串 <span class="math inline">\(P\)</span> 在字符串 <spanclass="math inline">\(S\)</span> 中所有出现的位置的起始下标。</p><h4 id="输入格式">输入格式</h4><p>第一行输入整数 <span class="math inline">\(N\)</span>，表示字符串<span class="math inline">\(P\)</span> 的长度。</p><p>第二行输入字符串 <span class="math inline">\(P\)</span>。</p><p>第三行输入整数 <span class="math inline">\(M\)</span>，表示字符串<span class="math inline">\(S\)</span> 的长度。</p><p>第四行输入字符串 <span class="math inline">\(S\)</span>。</p><h4 id="输出格式">输出格式</h4><p>共一行，输出所有出现位置的起始下标（下标从 <spanclass="math inline">\(0\)</span> 开始计数），整数之间用空格隔开。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1 \le N \le 10^5\)</span><br /><span class="math inline">\(1 \le M \le 10^6\)</span></p><h4 id="输入样例">输入样例：</h4><pre><code class="hljs">3aba5ababa</code></pre><h4 id="输出样例">输出样例：</h4><pre><code class="hljs">0 2</code></pre><hr /><h3 id="算法">算法</h3><h4 id="c-代码">C++ 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//Scanner会超时</span><br>        <span class="hljs-comment">// Scanner cin = new Scanner(System.in);</span><br>        <span class="hljs-type">int</span> n, m;<br>        String p, s;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out));<br>        n = Integer.parseInt(reader.readLine());<br>        p = reader.readLine();<br>        m = Integer.parseInt(reader.readLine());<br>        s = reader.readLine();<br>        <span class="hljs-comment">// n = cin.nextInt();</span><br>        <span class="hljs-comment">// p = cin.next();</span><br>        <span class="hljs-comment">// m = cin.nextInt();</span><br>        <span class="hljs-comment">// s = cin.next();</span><br>        p = <span class="hljs-string">&quot; &quot;</span> + p;<br>        s = <span class="hljs-string">&quot; &quot;</span> + s;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p.charAt(i) != p.charAt(j+<span class="hljs-number">1</span>))j = next[j];<br>            <span class="hljs-keyword">if</span>(p.charAt(j+<span class="hljs-number">1</span>) == p.charAt(i))<br>                j++;<br>            next[i] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p.charAt(j+<span class="hljs-number">1</span>) != s.charAt(i))j = next[j];<br>            <span class="hljs-keyword">if</span>(p.charAt(j+<span class="hljs-number">1</span>) == s.charAt(i))<br>                j++;<br>            <span class="hljs-keyword">if</span>(j == n)&#123;<br>                writer.write(i - n +<span class="hljs-string">&quot; &quot;</span>);<br>                j = next[j];<br>            &#125;<br>        &#125;<br>        writer.flush();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java8时间类</title>
    <link href="/2022/09/25/java8%E6%97%B6%E9%97%B4%E7%B1%BB/"/>
    <url>/2022/09/25/java8%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="date和calendar的缺点">Date和Calendar的缺点</h2><p>Java原本提供了Data和Calendar用于处理日期、时间的类，包括创建日期、时间对象，获取系统当前日期、时间等操作。但Date不仅无法实现国际化，而且它对不同属性也使用了前后矛盾的偏移量，比如月份与小时都是从0开始的，月份中的天则是从1开始的，年又是从1900开始的，而java.util.Calendar则显得过于复杂。从下面介绍可以看到Java对日期、时间处理不足。Java洗浴了Joda-Time库（一个被广泛使用的日期、时间库）的经验，提供了一套全新的日期时间库。</p><h2 id="定义">定义</h2><ul><li>LocalDateTime：A date-time without a time-zone in the ISO-8601calendar system, such as 2007-12-03T10:15:30.</li><li>ZonedDateTime：A date-time with a time-zone in the ISO-8601 calendarsystem, such as 2007-12-03T10:15:30+01:00 Europe/Paris.</li><li>ZoneId: A time-zone ID, such as Europe/Paris.</li><li>ZoneOffset:A time-zone offset from Greenwich/UTC, such as+02:00.</li></ul><p>LocalDateTime表示不带时区的时间，ZonedDateTime是由LocalDateTime和时区ZoneId或者LocalDateTime和与格林标准时间的差ZoneOffset组成</p><h3 id="使用">使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符串时间</span><br><span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2020-01-22 19:30:00&quot;</span>;<br><br><span class="hljs-comment">// 定义上海时区</span><br><span class="hljs-type">ZoneId</span> <span class="hljs-variable">zoneShanghai</span> <span class="hljs-operator">=</span> ZoneId.of(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>);<br><br><span class="hljs-comment">// 标准时间+3小时</span><br><span class="hljs-type">ZoneOffset</span> <span class="hljs-variable">zoneOffset</span> <span class="hljs-operator">=</span> ZoneOffset.ofHours(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 定义格式转换器</span><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br><span class="hljs-comment">// 字符串时间转换为LocalDateTime格式</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.from(formatter.parse(dateStr));<br><br><span class="hljs-comment">// 按上海时区定义ZonedDateTime时间</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">dateTime1</span> <span class="hljs-operator">=</span> ZonedDateTime.of(localDateTime,zoneShanghai);<br><br><span class="hljs-comment">// +3时区</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">dateTime2</span> <span class="hljs-operator">=</span> ZonedDateTime.of(localDateTime,zoneOffset);<br><br><span class="hljs-comment">// 日期转换，带时区</span><br><span class="hljs-type">String</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span> formatter.withZone(zoneShanghai).format(dateTime1);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span> formatter.withZone(zoneShanghai).format(dateTime2);<br><span class="hljs-comment">// time1 = &quot;2020-01-22 19:30:00&quot; , 对应的时区转换，日期没有问题</span><br><span class="hljs-comment">// time2 = &quot;2020-01-23 00:30:00&quot;， 使用了上海时区（+8小时时区），结果为+5个小时时间</span><br></code></pre></td></tr></table></figure><p>ZonedDateTime 和LocalDateTime时间格式都可以很方便的是做时间操作，下面仅已LocalDateTime举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加一天，一周，一月  ，判断两个日期</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">newTime</span> <span class="hljs-operator">=</span> localDateTime.plusDays(<span class="hljs-number">1L</span>);<br>newDate = localDateTime.plusWeeks(<span class="hljs-number">1L</span>);<br>newDate = localDateTime.plusMonths(<span class="hljs-number">1L</span>);<br><br>localDateTime.isAfter(newDate);  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 获取周、月等信息</span><br>newDate.getDayOfWeek();<br>newDate.getMonth();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
